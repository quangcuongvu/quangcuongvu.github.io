<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		<meta name="author" content="Alex Edwards">
		<meta name="copyright" content="Copyright Alex Edwards 2021">
		<title>Creating Secure Activation Tokens &mdash; Let's Go Further Further</title>
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<link rel="stylesheet" type="text/css" href="assets/css/main.css">
		<link rel="icon" type="image/x-icon" href="assets/img/favicon.ico">
	</head>
	<body>
		<header>
			<div class="wrapper">
				<div>
					
						
						<a href="00.00-front-matter.html">Let's Go Further</a> <span class="crumbs">&rsaquo; <a href="15.00-user-activation.html">User Activation</a> &rsaquo; Creating Secure Activation Tokens</span>
						
					
				</div>
				<div>
					&lsaquo; <a href="15.01-setting-up-the-tokens-database-table.html">Previous</a>
					&middot; <a href="00.01-contents.html">Contents</a> &middot;
					<a href="15.03-sending-activation-tokens.html">Next</a> &rsaquo;
				</div>
			</div>
		</header>
		<main class="wrapper text">
			<div class="chapter">Chapter 15.2.</div>
			<h2 id="creating-secure-activation-tokens">Creating Secure Activation Tokens</h2>

<p>The integrity of our activation process hinges on one key thing: the &lsquo;unguessability&rsquo; of the token that we send to the user&rsquo;s email address. If the token is easy to guess or can be brute-forced, then it would be possible for an attacker to activate a user&rsquo;s account even if they don&rsquo;t have access to the user&rsquo;s email inbox.</p>

<p>Because of this, we want the token to be generated by a <em>cryptographically secure random number generator</em> (CSPRNG) and have enough entropy (or <em>randomness</em>) that it is impossible to guess. In our case, we&rsquo;ll create our activation tokens using Go&rsquo;s <a href="https://golang.org/pkg/crypto/rand/"><code>crypto/rand</code></a> package and 128-bits (16 bytes) of entropy.</p>

<p>If you&rsquo;re following along, go ahead and create a new <code>internal/data/tokens.go</code> file. This will act as the home for all our logic related to creating and managing tokens over the next couple of chapters.</p>

<figure class="code bash">
<pre>$ touch internal/data/tokens.go</pre>
</figure>

<p>Then in this file let&rsquo;s define a <code>Token</code> struct (to represent the data for an individual token), and a <code>generateToken()</code> function that we can use to create a new token.</p>

<p>This is another time where it&rsquo;s probably easiest to jump straight into the code, and describe what&rsquo;s happening as we go along.</p>

<figure class="code go">
<figcaption>File: internal/data/tokens.go</figcaption>
<pre><span class="kn">package</span> <span class="nx">data</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;crypto/rand&#34;</span>
    <span class="s">&#34;crypto/sha256&#34;</span>
    <span class="s">&#34;encoding/base32&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="c1">// Define constants for the token scope. For now we just define the scope &#34;activation&#34;
</span><span class="c1"></span><span class="c1">// but we&#39;ll add additional scopes later in the book.
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">ScopeActivation</span> <span class="p">=</span> <span class="s">&#34;activation&#34;</span>
<span class="p">)</span>

<span class="c1">// Define a Token struct to hold the data for an individual token. This includes the 
</span><span class="c1"></span><span class="c1">// plaintext and hashed versions of the token, associated user ID, expiry time and 
</span><span class="c1"></span><span class="c1">// scope.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Token</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Plaintext</span> <span class="kt">string</span>
    <span class="nx">Hash</span>      <span class="p">[</span><span class="p">]</span><span class="kt">byte</span>
    <span class="nx">UserID</span>    <span class="kt">int64</span>
    <span class="nx">Expiry</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">Scope</span>     <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateToken</span><span class="p">(</span><span class="nx">userID</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">ttl</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">scope</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Token</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create a Token instance containing the user ID, expiry, and scope information.  
</span><span class="c1"></span>    <span class="c1">// Notice that we add the provided ttl (time-to-live) duration parameter to the 
</span><span class="c1"></span>    <span class="c1">// current time to get the expiry time?
</span><span class="c1"></span>    <span class="nx">token</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Token</span><span class="p">{</span>
        <span class="nx">UserID</span><span class="p">:</span> <span class="nx">userID</span><span class="p">,</span>
        <span class="nx">Expiry</span><span class="p">:</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">ttl</span><span class="p">)</span><span class="p">,</span>
        <span class="nx">Scope</span><span class="p">:</span>  <span class="nx">scope</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// Initialize a zero-valued byte slice with a length of 16 bytes.
</span><span class="c1"></span>    <span class="nx">randomBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="p">[</span><span class="p">]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

    <span class="c1">// Use the Read() function from the crypto/rand package to fill the byte slice with 
</span><span class="c1"></span>    <span class="c1">// random bytes from your operating system&#39;s CSPRNG. This will return an error if 
</span><span class="c1"></span>    <span class="c1">// the CSPRNG fails to function correctly.
</span><span class="c1"></span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">randomBytes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="c1">// Encode the byte slice to a base-32-encoded string and assign it to the token 
</span><span class="c1"></span>    <span class="c1">// Plaintext field. This will be the token string that we send to the user in their
</span><span class="c1"></span>    <span class="c1">// welcome email. They will look similar to this:
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Y3QMGX3PJ3WLRL2YRTQGQ6KRHU
</span><span class="c1"></span>    <span class="c1">// 
</span><span class="c1"></span>    <span class="c1">// Note that by default base-32 strings may be padded at the end with the = 
</span><span class="c1"></span>    <span class="c1">// character. We don&#39;t need this padding character for the purpose of our tokens, so 
</span><span class="c1"></span>    <span class="c1">// we use the WithPadding(base32.NoPadding) method in the line below to omit them.
</span><span class="c1"></span>    <span class="nx">token</span><span class="p">.</span><span class="nx">Plaintext</span> <span class="p">=</span> <span class="nx">base32</span><span class="p">.</span><span class="nx">StdEncoding</span><span class="p">.</span><span class="nf">WithPadding</span><span class="p">(</span><span class="nx">base32</span><span class="p">.</span><span class="nx">NoPadding</span><span class="p">)</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">randomBytes</span><span class="p">)</span>

    <span class="c1">// Generate a SHA-256 hash of the plaintext token string. This will be the value 
</span><span class="c1"></span>    <span class="c1">// that we store in the `hash` field of our database table. Note that the 
</span><span class="c1"></span>    <span class="c1">// sha256.Sum256() function returns an *array* of length 32, so to make it easier to  
</span><span class="c1"></span>    <span class="c1">// work with we convert it to a slice using the [:] operator before storing it.
</span><span class="c1"></span>    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nf">Sum256</span><span class="p">(</span><span class="p">[</span><span class="p">]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">Plaintext</span><span class="p">)</span><span class="p">)</span>
    <span class="nx">token</span><span class="p">.</span><span class="nx">Hash</span> <span class="p">=</span> <span class="nx">hash</span><span class="p">[</span><span class="p">:</span><span class="p">]</span>

    <span class="k">return</span> <span class="nx">token</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span></pre>
</figure>

<p>It&rsquo;s important to point out that the plaintext token strings we&rsquo;re creating here like <code>Y3QMGX3PJ3WLRL2YRTQGQ6KRHU</code> are <em>not</em> 16 characters long &mdash; but rather they have <em>an underlying entropy of 16 bytes of randomness</em>.</p>

<p>The length of the plaintext token string itself depends on <em>how those 16 random bytes are encoded to create a string</em>. In our case we encode the random bytes to a base-32 string, which results in a string with 26 characters. In contrast, if we encoded the random bytes using hexadecimal (base-16) the string would be 32 characters long instead.</p>

<h3 id="creating-the-tokenmodel-and-validation-checks">Creating the TokenModel and Validation Checks</h3>

<p>OK, let&rsquo;s move on and set up a <code>TokenModel</code> type which encapsulates the database interactions with our PostgreSQL <code>tokens</code> table. We&rsquo;ll follow a very similar pattern to the <code>MovieModel</code> and <code>UsersModel</code> again, and we&rsquo;ll implement the following three methods on it:</p>

<ul>
<li><code>Insert()</code> to insert a new token record in the database.</li>
<li><code>New()</code> will be a shortcut method which creates a new token using the <code>generateToken()</code> function and then calls <code>Insert()</code> to store the data.</li>
<li><code>DeleteAllForUser()</code> to delete all tokens with a specific scope for a specific user.</li>
</ul>

<p>We&rsquo;ll also create a new <code>ValidateTokenPlaintext()</code> function, which will check that a plaintext token provided by a client in the future is exactly 26 bytes long.</p>

<p>Open up the <code>internal/data/tokens.go</code> file again, and add the following code:</p>

<figure class="code go">
<figcaption>File: internal/data/tokens.go</figcaption>
<pre><span class="kn">package</span> <span class="nx">data</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span> <span class="c1">// New import
</span><span class="c1"></span>    <span class="s">&#34;crypto/rand&#34;</span>
    <span class="s">&#34;crypto/sha256&#34;</span>
    <span class="s">&#34;database/sql&#34;</span> <span class="c1">// New import
</span><span class="c1"></span>    <span class="s">&#34;encoding/base32&#34;</span>
    <span class="s">&#34;time&#34;</span>

    <span class="s">&#34;greenlight.alexedwards.net/internal/validator&#34;</span> <span class="c1">// New import
</span><span class="c1"></span><span class="p">)</span>

<span class="o">...</span>

<span class="c1">// Check that the plaintext token has been provided and is exactly 26 bytes long.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ValidateTokenPlaintext</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validator</span><span class="p">,</span> <span class="nx">tokenPlaintext</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nx">tokenPlaintext</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;token&#34;</span><span class="p">,</span> <span class="s">&#34;must be provided&#34;</span><span class="p">)</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">Check</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">tokenPlaintext</span><span class="p">)</span> <span class="o">==</span> <span class="mi">26</span><span class="p">,</span> <span class="s">&#34;token&#34;</span><span class="p">,</span> <span class="s">&#34;must be 26 bytes long&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Define the TokenModel type.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TokenModel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">DB</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span>
<span class="p">}</span>

<span class="c1">// The New() method is a shortcut which creates a new Token struct and then inserts the
</span><span class="c1"></span><span class="c1">// data in the tokens table.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">TokenModel</span><span class="p">)</span> <span class="nf">New</span><span class="p">(</span><span class="nx">userID</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">ttl</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">scope</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Token</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">generateToken</span><span class="p">(</span><span class="nx">userID</span><span class="p">,</span> <span class="nx">ttl</span><span class="p">,</span> <span class="nx">scope</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">err</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Insert</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">token</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// Insert() adds the data for a specific token to the tokens table.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">TokenModel</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">token</span> <span class="o">*</span><span class="nx">Token</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">query</span> <span class="o">:=</span> <span class="s">`</span><span class="s">
</span><span class="s">        INSERT INTO tokens (hash, user_id, expiry, scope) 
</span><span class="s">        VALUES ($1, $2, $3, $4)</span><span class="s">`</span>

    <span class="nx">args</span> <span class="o">:=</span> <span class="p">[</span><span class="p">]</span><span class="kd">interface</span><span class="p">{</span><span class="p">}</span><span class="p">{</span><span class="nx">token</span><span class="p">.</span><span class="nx">Hash</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nx">UserID</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Expiry</span><span class="p">,</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Scope</span><span class="p">}</span>

    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nf">cancel</span><span class="p">(</span><span class="p">)</span>

    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">DB</span><span class="p">.</span><span class="nf">ExecContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="c1">// DeleteAllForUser() deletes all tokens for a specific user and scope.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">TokenModel</span><span class="p">)</span> <span class="nf">DeleteAllForUser</span><span class="p">(</span><span class="nx">scope</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">userID</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">query</span> <span class="o">:=</span> <span class="s">`</span><span class="s">
</span><span class="s">        DELETE FROM tokens 
</span><span class="s">        WHERE scope = $1 AND user_id = $2</span><span class="s">`</span>

    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nf">cancel</span><span class="p">(</span><span class="p">)</span>

    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">DB</span><span class="p">.</span><span class="nf">ExecContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">userID</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</pre>
</figure>

<p>And finally, we need to update the <code>internal/data/models.go</code> file so that the new <code>TokenModel</code> is included in our parent <code>Models</code> struct. Like so:</p>

<figure class="code go">
<figcaption>File: internal/data/models.go</figcaption>
<pre><span class="kn">package</span> <span class="nx">data</span>

<span class="o">...</span>

<span class="kd">type</span> <span class="nx">Models</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Movies</span> <span class="nx">MovieModel</span>
    <span class="nx">Tokens</span> <span class="nx">TokenModel</span> <span class="c1">// Add a new Tokens field.
</span><span class="c1"></span>    <span class="nx">Users</span>  <span class="nx">UserModel</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewModels</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span> <span class="nx">Models</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Models</span><span class="p">{</span>
        <span class="nx">Movies</span><span class="p">:</span> <span class="nx">MovieModel</span><span class="p">{</span><span class="nx">DB</span><span class="p">:</span> <span class="nx">db</span><span class="p">}</span><span class="p">,</span>
        <span class="nx">Tokens</span><span class="p">:</span> <span class="nx">TokenModel</span><span class="p">{</span><span class="nx">DB</span><span class="p">:</span> <span class="nx">db</span><span class="p">}</span><span class="p">,</span> <span class="c1">// Initialize a new TokenModel instance.
</span><span class="c1"></span>        <span class="nx">Users</span><span class="p">:</span>  <span class="nx">UserModel</span><span class="p">{</span><span class="nx">DB</span><span class="p">:</span> <span class="nx">db</span><span class="p">}</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span></pre>
</figure>

<p>At this point you should be able to restart the application, and everything should work without a hitch.</p>

<figure class="code bash">
<pre>$ go run ./cmd/api/
<samp>{&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2021-04-15T16:07:58Z&#34;,&#34;message&#34;:&#34;database connection pool established&#34;}
{&#34;level&#34;:&#34;INFO&#34;,&#34;time&#34;:&#34;2021-04-15T16:07:58Z&#34;,&#34;message&#34;:&#34;starting server&#34;,&#34;properties&#34;:{&#34;addr&#34;:&#34;:4000&#34;,&#34;env&#34;:&#34;development&#34;}}</samp></pre>
</figure>

<hr />

<h3 id="additional-information">Additional Information</h3>

<h4 id="the-math-rand-package">The math/rand package</h4>

<p>Go also has a <a href="https://golang.org/pkg/math/rand/"><code>math/rand</code></a> package which provides a <em>deterministic</em> pseudo-random number generator (PRNG). It&rsquo;s important that you never use the <code>math/rand</code> package for any purpose where cryptographic security is required, such as generating tokens or secrets like we are here.</p>

<p>In fact, it&rsquo;s arguably best to use <code>crypto/rand</code> as <em>standard practice</em>. Only opt for using <code>math/rand</code> in specific scenarios where you are certain that a deterministic PRNG is acceptable, and you actively need the <a href="https://blog.gopheracademy.com/advent-2017/a-tale-of-two-rands/#tradeoffs">faster performance</a> of <code>math/rand</code>.</p>

			
		</main>
		<footer>
			<div class="wrapper">
				<div>
					&lsaquo; <a href="15.01-setting-up-the-tokens-database-table.html">Previous</a>
				</div>
				<div>
					<a href="00.01-contents.html">Contents</a>
				</div>
				<div>
					<a href="15.03-sending-activation-tokens.html">Next</a> &rsaquo;
				</div>
			</div>
		</footer>
	</body>
</html>
